* HML Solver and \(\LaTeX\) Export
  This is a simple tool, which allows solving n-nested-recursive Systems on LTS and export the required
  calculations as \LaTeX Code. The exported Script uses following macros to model HML-Fromula

  #+begin_src latex
\newcommand{\ff}{f\hspace{-0.45em}f}
\newcommand{\tt}{t\!t}
\renewcommand{\eval}[1]{\left\llbracket \, #1 \,\right\rrbracket}
\newcommand{\Ex}[2][]{\langle#1 \mathrm{#2} #1 \rangle}
\newcommand{\All}[2][]{[#1 \mathrm{#2} #1]}
  #+end_src

* Usage
** Define LTS
   Define Processlabels, Actions and Variables
   #+begin_src haskell
   data Proc = P0|P1|P2|P3 deriving (Eq, Ord, Show)
   data Act = A|B                          deriving (Eq, Ord,Show)
   data Variables = X|Y|Z                      deriving (Eq, Show, Ord)
   #+end_src
Proc and Act need both instances of =Eq,Ord= since the Algorithm uses =Data.Set= to solve equations. The =Show= instance is used to render objects when producing a Formular. One might use custom =Show= instances  instead to allow for pretty \(LaTeX\) export. It's also possible to define the Processlabels as =data Proc = Proc String=, which would ease the implementation of pretty \(\LaTeX\) printing, though this apporach is discouraged since it allows miskates like misspellings when defining HML Formulars. Same applies to =Act=
and =Variables=.


The =Lib= Module exports definitions for =Transition p a= which model /T/ part of an LTS. Using the function =ltsFromTrans :: Set (Transition p a) -> LTS p a= allows infering a whole LTS from a Set of Transitions.
#+begin_src haskell
trans = fromList [
  Transition P1 A P0,
  Transition P1 B P3,
  Transition P3 A P0,
  Transition P4 B P1,
  Transition P1 A P2,
  Transition P2 B P2,
  Transition P3 B P3]

lts = ltsFromTrans trans
#+end_src

** Defining System of Equations
   Let's asume we want to solve a System of Equation like follows
   \begin{align*}
    F = Z\hspace{0.5cm}\mathrm{with} \hspace{0.5cm} & Z \overset{\mathrm Min}=([A]Y \land <B>X)\lor [B]Z\\
              &Y \overset{\mathrm Max}= <B>X \land <\mathrm{Act}>Y\\
         &X \overset{\mathrm Max}= <B> t\!\!\!t\land <A>Y \land [B]X
   \end{align*}
where \(V\) is our Set of Variables and \(F\in \mathcal M_{V}\) is a HML Formular.

We want to define a /Declaration/ \(f:V\to \{\mathrm{Max},\mathrm{Min}\}\times \mathcal M_{V}\), mapping Variables to their Definitions. This might look like this
#+begin_src haskell
decl :: Declaration Act Variable
decl Z = Min $ (All [A] (Var Y) `And` Ex [B] (Var X)) `Or` All [B] (Var Z)
decl Y = Max $ Ex [B] (Var X) `And` Ex acts (Var Y)       where acts = Data.Set.toList . act $ lts
decl X = Max $ Ex [B] TT `And` Ex [A] (Var Y) `And` All [B] (Var X)
#+end_src
where we use the =act= record accessor to retrieve all Actions defined in our LTS.  =Min= and =Max= are constructors for the =Fixpiont a= datatype.

** Create n-nested recursive System
   The fucntion =makeSystem :: HML a v -> Declaration a v -> HMLEquation a v= will transform the declaration into a n-nested-recursive System if possible. When the declaration is malformed, this means it contains mutually recursive Variables of varied Fixpoint-Types the function will return =Nothing=.
** Solve System on LTS
   At last you'd use the function =solveSystem :: LTS p a -> HMLEquation a v -> String= which solves the whole System and produces the \(\LaTeX\) Code documenting the calculation steps as a String.
   The Result might look like this
   #+begin_src latex
   \newcommand{\ff}{f\hspace{-0.45em}f}
   \newcommand{\tt}{t\!t}
   \renewcommand{\eval}[1]{\left\llbracket \, #1 \,\right\rrbracket}
   \newcommand{\Ex}[2][]{\langle#1 \mathrm{#2} #1 \rangle}
   \newcommand{\All}[2][]{[#1 \mathrm{#2} #1]}
   
      \mathcal O_{F_i;\eval{\chi^{<i}}}(Proc, Proc)  &= (\mathcal O_{\Ex{B}\tt \land \Ex{A}Y \land \All{B}X}(Proc, Proc), \mathcal O_{\Ex{B}X \land \Ex{A, B}Y}(Proc, Proc))\\
       &= (\Ex[\cdot]{B}Proc \cap \Ex[\cdot]{A}\{P0, P1, P2, P3, P4\} \cap \All[\cdot]{B}\{P0, P1, P2, P3, P4\}, \Ex[\cdot]{B}\{P0, P1, P2, P3, P4\} \cap \Ex[\cdot]{A, B}\{P0, P1, P2, P3, P4\})\\
       &= (\{P1, P3\}, \{P1, P2, P3, P4\})\\
      \mathcal O_{F_i;\eval{\chi^{<i}}}(\{P1, P3\}, \{P1, P2, P3, P4\})  &= (\mathcal O_{\Ex{B}\tt \land \Ex{A}Y \land \All{B}X}(\{P1, P3\}, \{P1, P2, P3, P4\}), \mathcal O_{\Ex{B}X \land \Ex{A, B}Y}(\{P1, P3\}, \{P1, P2, P3, P4\}))\\
       &= (\Ex[\cdot]{B}Proc \cap \Ex[\cdot]{A}\{P1, P2, P3, P4\} \cap \All[\cdot]{B}\{P1, P3\}, \Ex[\cdot]{B}\{P1, P3\} \cap \Ex[\cdot]{A, B}\{P1, P2, P3, P4\})\\
       &= (\{P1\}, \{P1, P3, P4\})\\
      \mathcal O_{F_i;\eval{\chi^{<i}}}(\{P1\}, \{P1, P3, P4\})  &= (\mathcal O_{\Ex{B}\tt \land \Ex{A}Y \land \All{B}X}(\{P1\}, \{P1, P3, P4\}), \mathcal O_{\Ex{B}X \land \Ex{A, B}Y}(\{P1\}, \{P1, P3, P4\}))\\
       &= (\Ex[\cdot]{B}Proc \cap \Ex[\cdot]{A}\{P1, P3, P4\} \cap \All[\cdot]{B}\{P1\}, \Ex[\cdot]{B}\{P1\} \cap \Ex[\cdot]{A, B}\{P1, P3, P4\})\\
       &= (\{\}, \{P4\})\\
      \mathcal O_{F_i;\eval{\chi^{<i}}}(\emptyset, \{P4\})  &= (\mathcal O_{\Ex{B}\tt \land \Ex{A}Y \land \All{B}X}(\emptyset, \{P4\}), \mathcal O_{\Ex{B}X \land \Ex{A, B}Y}(\emptyset, \{P4\}))\\
       &= (\Ex[\cdot]{B}Proc \cap \Ex[\cdot]{A}\{P4\} \cap \All[\cdot]{B}\{\}, \Ex[\cdot]{B}\{\} \cap \Ex[\cdot]{A, B}\{P4\})\\
       &= (\{\}, \{\})\\
      \mathcal O_{F_i;\eval{\chi^{<i}}}(\emptyset, \emptyset)  &= (\mathcal O_{\Ex{B}\tt \land \Ex{A}Y \land \All{B}X}(\emptyset, \emptyset), \mathcal O_{\Ex{B}X \land \Ex{A, B}Y}(\emptyset, \emptyset))\\
       &= (\Ex[\cdot]{B}Proc \cap \Ex[\cdot]{A}\{\} \cap \All[\cdot]{B}\{\}, \Ex[\cdot]{B}\{\} \cap \Ex[\cdot]{A, B}\{\})\\
       &= (\{\}, \{\})\\
      \mathcal O_{F_i;\eval{\chi^{<i}}}(\emptyset)  &= (\mathcal O_{\All{A}Y \land \Ex{B}X \lor \All{B}Z}(\emptyset))\\
       &= (\All[\cdot]{A}\{\} \cap \Ex[\cdot]{B}\{\} \cup \All[\cdot]{B}\{\})\\
       &= (\{P0\})\\
      \mathcal O_{F_i;\eval{\chi^{<i}}}(\{P0\})  &= (\mathcal O_{\All{A}Y \land \Ex{B}X \lor \All{B}Z}(\{P0\}))\\
       &= (\All[\cdot]{A}\{\} \cap \Ex[\cdot]{B}\{\} \cup \All[\cdot]{B}\{P0\})\\
       &= (\{P0\})   
   #+end_src
